package fr.acinq.eclair.blockchain.bitcoind


import akka.actor.typed.Behavior
import akka.actor.typed.scaladsl.{ActorContext, Behaviors, TimerScheduler}
import fr.acinq.bitcoin.scalacompat.{BlockHash, Script, addressToPublicKeyScript}
import fr.acinq.bitcoin.scalacompat.Crypto.PublicKey
import fr.acinq.eclair.blockchain.OnChainAddressGenerator
import scodec.bits.ByteVector

import java.util.concurrent.atomic.AtomicReference
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration.FiniteDuration
import scala.util.{Failure, Success}

/**
 * Handles the renewal of public keys and public key scripts generated by bitcoin core and used to send onchain funds to when channels get closed
 */
object OnchainPubkeyRefresher {

  // @formatter:off
  sealed trait Command
  case object RenewPubkey extends Command
  private case class SetPubkey(pubkey: PublicKey) extends Command
  case object RenewPubkeyScript extends Command
  private case class SetPubkeyScript(pubkeyScript: ByteVector) extends Command
  private case class Error(reason: Throwable) extends Command
  private case object Done extends Command
  // @formatter:on

  def apply(chainHash: BlockHash, generator: OnChainAddressGenerator, finalPubkey: AtomicReference[PublicKey], finalPubkeyScript: AtomicReference[ByteVector], delay: FiniteDuration): Behavior[Command] = {
    Behaviors.setup { context =>
      Behaviors.withTimers { timers =>
        new OnchainPubkeyRefresher(chainHash, generator, finalPubkey, finalPubkeyScript, context, timers, delay).idle()
      }
    }
  }
}

private class OnchainPubkeyRefresher(chainHash: BlockHash, generator: OnChainAddressGenerator, finalPubkey: AtomicReference[PublicKey], finalPubkeyScript: AtomicReference[ByteVector], context: ActorContext[OnchainPubkeyRefresher.Command], timers: TimerScheduler[OnchainPubkeyRefresher.Command], delay: FiniteDuration) {

  import OnchainPubkeyRefresher._

  def idle(): Behavior[Command] = Behaviors.receiveMessagePartial {
    case RenewPubkey =>
      context.log.debug(s"received RenewPubkey current pubkey is ${finalPubkey.get()}")
      context.pipeToSelf(generator.getP2wpkhPubkey()) {
        case Success(pubkey) => SetPubkey(pubkey)
        case Failure(reason) => Error(reason)
      }
      Behaviors.receiveMessagePartial {
        case SetPubkey(script) =>
          timers.startSingleTimer(Done, delay) // wait a bit to avoid generating too many addresses in case of mass channel force-close
          waiting(script)
        case Error(reason) =>
          context.log.error("cannot generate new onchain address", reason)
          Behaviors.same
      }
    case RenewPubkeyScript =>
      context.log.debug(s"received Renew current script is ${finalPubkeyScript.get()}")
      context.pipeToSelf(generator.getReceiveAddress("")) {
        case Success(address) => addressToPublicKeyScript(chainHash, address) match {
          case Right(script) => SetPubkeyScript(Script.write(script))
          case Left(error) => Error(error.getCause)
        }
        case Failure(reason) => Error(reason)
      }
      Behaviors.receiveMessagePartial {
        case SetPubkeyScript(script) =>
          timers.startSingleTimer(Done, delay) // wait a bit to avoid generating too many addresses in case of mass channel force-close
          waiting(script)
        case Error(reason) =>
          context.log.error("cannot generate new onchain address", reason)
          Behaviors.same
      }
  }

  def waiting(pubkey: PublicKey): Behavior[Command] = Behaviors.receiveMessagePartial {
    case Done =>
      context.log.info(s"setting final onchain public key to $pubkey")
      finalPubkey.set(pubkey)
      idle()
  }

  def waiting(script: ByteVector): Behavior[Command] = Behaviors.receiveMessagePartial {
    case Done =>
      context.log.info(s"setting final onchain script to $script")
      finalPubkeyScript.set(script)
      idle()
  }
}
