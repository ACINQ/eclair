package fr.acinq.eclair.blockchain.bitcoind


import akka.actor.typed.Behavior
import akka.actor.typed.scaladsl.{ActorContext, Behaviors, TimerScheduler}
import fr.acinq.bitcoin.scalacompat.Crypto.PublicKey
import fr.acinq.bitcoin.scalacompat.{Script, ScriptElt}
import fr.acinq.eclair.blockchain.OnChainAddressGenerator

import java.util.concurrent.atomic.AtomicReference
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration.FiniteDuration
import scala.util.{Failure, Success}

/**
 * Handles the renewal of on-chain addresses generated by bitcoin core and used to receive on-chain funds when channels get closed.
 */
object OnChainAddressRefresher {

  // @formatter:off
  sealed trait Command
  case object RenewPubkey extends Command
  case object RenewPubkeyScript extends Command
  private case class SetPubkey(pubkey: PublicKey) extends Command
  private case class SetPubkeyScript(script: Seq[ScriptElt]) extends Command
  private case class Error(reason: Throwable) extends Command
  private case object Done extends Command
  // @formatter:on

  // @formatter:off
  sealed trait Renewing[T]
  private object Renewing {
    case class Idle[T]() extends Renewing[T]
    case class Pending[T](current: T) extends Renewing[T]
    case class Renewed[T](next: T) extends Renewing[T]
  }
  // @formatter:on

  def apply(generator: OnChainAddressGenerator, finalPubkey: AtomicReference[PublicKey], finalPubkeyScript: AtomicReference[Seq[ScriptElt]], delay: FiniteDuration): Behavior[Command] = {
    Behaviors.setup { context =>
      Behaviors.withTimers { timers =>
        val refresher = new OnChainAddressRefresher(generator, finalPubkey, finalPubkeyScript, context, timers, delay)
        refresher.waiting(Renewing.Idle(), Renewing.Idle())
      }
    }
  }
}

private class OnChainAddressRefresher(generator: OnChainAddressGenerator,
                                      finalPubkey: AtomicReference[PublicKey],
                                      finalPubkeyScript: AtomicReference[Seq[ScriptElt]],
                                      context: ActorContext[OnChainAddressRefresher.Command],
                                      timers: TimerScheduler[OnChainAddressRefresher.Command], delay: FiniteDuration) {

  import OnChainAddressRefresher._

  /**
   * We rate-limit renewing our public key or script: whenever we initiate a renew, we will ignore additional renew
   * requests until we've received the new value from bitcoind and waited for a configurable [[delay]].
   * This ensures that a burst of requests during a mass force-close use the same final on-chain address instead of
   * creating a lot of address churn on our bitcoin wallet.
   */
  def waiting(pubkeyStatus: Renewing[PublicKey], scriptStatus: Renewing[Seq[ScriptElt]]): Behavior[Command] = Behaviors.receiveMessage {
    case RenewPubkey =>
      pubkeyStatus match {
        case _: Renewing.Idle[_] =>
          val current = finalPubkey.get()
          context.log.debug("renewing pubkey (current={})", current)
          context.pipeToSelf(generator.getP2wpkhPubkey()) {
            case Success(pubkey) => SetPubkey(pubkey)
            case Failure(reason) => Error(reason)
          }
          waiting(Renewing.Pending(current), scriptStatus)
        case Renewing.Pending(_) => Behaviors.same
        case Renewing.Renewed(_) => Behaviors.same
      }
    case RenewPubkeyScript =>
      scriptStatus match {
        case _: Renewing.Idle[_] =>
          val current = finalPubkeyScript.get()
          context.log.debug("renewing script (current={})", Script.write(current).toHex)
          context.pipeToSelf(generator.getReceivePublicKeyScript()) {
            case Success(script) => SetPubkeyScript(script)
            case Failure(reason) => Error(reason)
          }
          waiting(pubkeyStatus, Renewing.Pending(current))
        case Renewing.Pending(_) => Behaviors.same
        case Renewing.Renewed(_) => Behaviors.same
      }
    case SetPubkey(pubkey) =>
      timers.startSingleTimer(Done, delay)
      waiting(Renewing.Renewed(pubkey), scriptStatus)
    case SetPubkeyScript(script) =>
      timers.startSingleTimer(Done, delay)
      waiting(pubkeyStatus, Renewing.Renewed(script))
    case Error(reason) =>
      context.log.error("cannot renew public key or script", reason)
      waiting(Renewing.Idle(), Renewing.Idle())
    case Done =>
      val pubkeyStatus1 = pubkeyStatus match {
        case _: Renewing.Idle[_] => pubkeyStatus
        case Renewing.Pending(_) => pubkeyStatus
        case Renewing.Renewed(next) =>
          context.log.info("setting pubkey to {}", next)
          finalPubkey.set(next)
          Renewing.Idle[PublicKey]()
      }
      val scriptStatus1 = scriptStatus match {
        case _: Renewing.Idle[_] => scriptStatus
        case Renewing.Pending(_) => scriptStatus
        case Renewing.Renewed(next) =>
          context.log.info("setting script to {}", Script.write(next).toHex)
          finalPubkeyScript.set(next)
          Renewing.Idle[Seq[ScriptElt]]()
      }
      waiting(pubkeyStatus1, scriptStatus1)
  }

}
